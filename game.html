<!DOCTYPE html>

<html lang="en">

<head>

<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>UMD Drop and Catch Game</title>
<link rel="stylesheet" href="CSS/styles.css" />
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

<style>

* {

margin: 0;

padding: 0;

box-sizing: border-box;

}


body {
 font-family: 'Poppins', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}

.game-page {
 background: linear-gradient(135deg, #7A0019 0%, #FFCC33 100%);
 display: flex;
 justify-content: center;
 align-items: center;
 padding: 24px 0;
 gap: 20px;
}


.game-container {

position: relative;

width: 400px;

height: 600px;

background: linear-gradient(to bottom, #FFCC33 0%, #7A0019 100%);

border: 3px solid #7A0019;

border-radius: 15px;

overflow: hidden;

box-shadow: 0 10px 30px rgba(122,0,25,0.4);

}


.game-header {

background: rgba(122,0,25,0.9);

color: #FFCC33;

padding: 10px;

text-align: center;

font-size: 18px;

font-weight: bold;

}


.score-board {

display: flex;

justify-content: space-between;

padding: 5px 20px;

background: rgba(255,204,51,0.9);

color: #7A0019;

font-weight: bold;

}


.game-area {

position: relative;

width: 100%;

height: calc(100% - 80px);

background: linear-gradient(to bottom, #FFF8DC 0%, #F5F5DC 100%);

}


.catcher {

position: absolute;

bottom: 20px;

left: 50%;

transform: translateX(-50%);

width: 80px;

height: 20px;

background: linear-gradient(45deg, #7A0019, #FFCC33);

border-radius: 10px;

box-shadow: 0 4px 8px rgba(122,0,25,0.4);

transition: left 0.1s ease;

}


.falling-object {

position: absolute;

width: 50px;

height: 50px;

border-radius: 50%;

/* Drop shadow removed for cleaner look */

animation: fall linear;

}


.good-object {

/* UMD Bulldog image for good objects */

background: url('images/umd-bulldog.png') center center / contain no-repeat;

width: 50px; /* match increased object size */

height: 50px;

border-radius: 0; /* keep logo shape */

background-color: transparent;

}


.bad-object {

/* UMD Maryland flag ball for bad objects */

background: url('images/umd-maryland.png') center center / cover no-repeat;

width: 50px;

height: 50px;

border-radius: 50%;

background-color: transparent;

}


.bonus-object {

/* Gold Bulldog image for bonus objects */

background: url('images/umd-bulldog-gold.png') center center / contain no-repeat;

width: 50px; /* match increased object size */

height: 50px;

border-radius: 0; /* keep logo shape */

background-color: transparent;

/* No extra animation here so it inherits the fall animation */

}


@keyframes fall {

from {

top: -30px;

}

to {

top: 100%;

}

}


@keyframes sparkle {

0%, 100% { transform: scale(1); }

50% { transform: scale(1.2); }

}


.game-over {

position: absolute;

top: 50%;

left: 50%;

transform: translate(-50%, -50%);

background: rgba(0,0,0,0.9);

color: white;

padding: 30px;

border-radius: 15px;

text-align: center;

display: none;

}


.game-over h2 {

margin-bottom: 20px;

color: #FFCC33;

}


.restart-btn {

background: linear-gradient(45deg, #7A0019, #FFCC33);

color: white;

border: none;

padding: 10px 20px;

border-radius: 25px;

font-size: 16px;

cursor: pointer;

margin-top: 15px;

transition: transform 0.2s;

}


.restart-btn:hover {

transform: scale(1.05);

}


.instructions {
position: relative;
background: rgba(122,0,25,0.8);
color: #FFCC33;
padding: 10px;
border-radius: 10px;
font-size: 12px;
max-width: 200px;
}


.level-indicator {
position: right;
background: rgba(255,204,51,0.9);
padding: 5px 10px;
border-radius: 15px;
font-weight: bold;
color: #7A0019;
}

.music-control {
background: rgba(122,0,25,0.9);
color: #FFCC33;
border: 2px solid #FFCC33;
padding: 10px 16px;
border-radius: 20px;
cursor: pointer;
font-size: 14px;
font-weight: bold;
transition: all 0.3s ease;
align-self: flex-start;
margin-top: 20px;
height: fit-content;
}

.music-control:hover {
background: rgba(255,204,51,0.9);
color: #7A0019;
transform: scale(1.05);
}

.music-control.muted {
opacity: 0.6;
}

</style>

</head>

<body>

  <div class="welcome-banner">
    UMD Drop and Catch Game
  </div>

  <nav class="navbar">
    <div class="logo"></div>
    <ul class="nav-links">
      <li><a href="index.html"><i class="fas fa-home"></i> Home</a></li>
      <li><a href="hobbies.html"><i class="fas fa-heart"></i> Hobbies</a></li>
      <li><a href="discover.html"><i class="fas fa-university"></i> Discover UMD</a></li>
      <li><a href="resume.html"><i class="fas fa-file-alt"></i> Resume</a></li>
      <li><a href="career.html"><i class="fas fa-briefcase"></i> Career</a></li>
      <li class="active"><a href="game.html"><i class="fas fa-gamepad"></i> Game</a></li>
    </ul>
    <div class="hamburger">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </nav>

  <main class="container">
    <div class="game-page">
      <div class="instructions">
        üéÆ Use A/D or ‚Üê/‚Üí to move<br>
        üü¢ Catch Champ for (+10)<br>
        üî¥ Avoid University of Maryland (-20 points, -1 life)<br>
        üü° Catch gold Champ for bonus (+50)
      </div>
      
      <div class="game-container">

<div class="game-header">

UMD Drop and Catch Game

</div>


<div class="score-board">

<div>Score: <span id="score">0</span></div>

<div>Lives: <span id="lives">3</span></div>

</div>




<div class="game-area" id="gameArea">

<div class="catcher" id="catcher"></div>

</div>


<div class="game-over" id="gameOver">

<h2>Game Over!</h2>

<p>Final Score: <span id="finalScore">0</span></p>

<p>Level Reached: <span id="finalLevel">1</span></p>

<button class="restart-btn" onclick="restartGame()">Play Again</button>

</div>

      </div>
      
      <div class="level-indicator">Level: <span id="level">1</span></div>
      
      <button class="music-control" id="musicToggle" onclick="toggleMusic()">
        <i class="fas fa-music"></i> Music: ON
      </button>
      
    </div>
  </main>

  <!-- Audio elements for music and sound effects -->
  <!-- Background music is generated using Web Audio API - no files needed! -->

<script>

class DropCatchGame {

constructor() {

this.gameArea = document.getElementById('gameArea');

this.catcher = document.getElementById('catcher');

this.scoreElement = document.getElementById('score');

this.livesElement = document.getElementById('lives');

this.levelElement = document.getElementById('level');

this.gameOverElement = document.getElementById('gameOver');

this.finalScoreElement = document.getElementById('finalScore');

this.finalLevelElement = document.getElementById('finalLevel');


// Audio elements
this.audioContext = null;
this.backgroundMusicSource = null;
this.musicGainNode = null;
this.musicEnabled = true;

// Sound effects (using Web Audio API)
this.catchSoundContext = null;
this.bonusSoundContext = null;
this.missSoundContext = null;
this.badCatchSoundContext = null;
this.gameOverSoundContext = null;


this.score = 0;

this.lives = 3;

this.level = 1;

this.gameRunning = false;

this.catcherPosition = 50; // percentage

this.fallingObjects = [];

this.gameSpeed = 2000; // milliseconds between drops

this.dropInterval = null;


this.init();

}


init() {

this.setupEventListeners();
this.initAudio();
this.startGame();

}

initAudio() {

try {

// Initialize Web Audio API

this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

this.musicGainNode = this.audioContext.createGain();

this.musicGainNode.connect(this.audioContext.destination);

} catch (e) {

console.log('Web Audio API not supported:', e);

}

}


setupEventListeners() {

document.addEventListener('keydown', (e) => {

if (!this.gameRunning) return;


switch(e.key.toLowerCase()) {

case 'a':

case 'arrowleft':

this.moveCatcher(-10);

break;

case 'd':

case 'arrowright':

this.moveCatcher(10);

break;

}

});


// Touch/mouse support for mobile

this.gameArea.addEventListener('click', (e) => {

if (!this.gameRunning) return;


const rect = this.gameArea.getBoundingClientRect();

const clickX = e.clientX - rect.left;

const clickPercentage = (clickX / rect.width) * 100;


if (clickPercentage < this.catcherPosition) {

this.moveCatcher(-20);

} else {

this.moveCatcher(20);

}

});

}


moveCatcher(delta) {

this.catcherPosition = Math.max(0, Math.min(100, this.catcherPosition + delta));

this.catcher.style.left = this.catcherPosition + '%';

}


startGame() {

this.gameRunning = true;

this.score = 0;

this.lives = 3;

this.level = 1;

this.gameSpeed = 2000;

this.fallingObjects = [];


this.updateDisplay();

this.gameOverElement.style.display = 'none';

// Stop any existing music
if (this.backgroundMusicSource) {
try {
if (this.backgroundMusicSource.osc1) this.backgroundMusicSource.osc1.stop();
if (this.backgroundMusicSource.osc2) this.backgroundMusicSource.osc2.stop();
if (this.backgroundMusicSource.osc3) this.backgroundMusicSource.osc3.stop();
if (this.backgroundMusicSource.musicTimeout) {
clearTimeout(this.backgroundMusicSource.musicTimeout);
}
} catch (e) {
// Oscillators may already be stopped
}
this.backgroundMusicSource = null;
}

// Play background music if enabled
if (this.musicEnabled && this.audioContext) {
// Resume audio context if suspended (browser autoplay policy)
if (this.audioContext.state === 'suspended') {
this.audioContext.resume().then(() => {
this.playElevatorMusic();
}).catch(e => console.log('Could not resume audio context:', e));
} else {
this.playElevatorMusic();
}
}


this.dropInterval = setInterval(() => {

this.createFallingObject();

}, this.gameSpeed);


this.gameLoop();

}


createFallingObject() {

if (!this.gameRunning) return;


const object = document.createElement('div');

object.className = 'falling-object';


// Random position

const leftPosition = Math.random() * 85 + 7.5; // 7.5% to 92.5%

object.style.left = leftPosition + '%';


// Random object type

const objectType = Math.random();

let points = 0;

let isBad = false;


if (objectType < 0.6) {

// 60% chance for good object

object.classList.add('good-object');

points = 10;

} else if (objectType < 0.9) {

// 30% chance for bad object

object.classList.add('bad-object');

isBad = true;

} else {

// 10% chance for bonus object

object.classList.add('bonus-object');

points = 50;

}


// Random fall speed

const fallSpeed = Math.random() * 2 + 1; // 1-3 seconds

object.style.animationDuration = fallSpeed + 's';


this.gameArea.appendChild(object);


this.fallingObjects.push({

element: object,

left: leftPosition,

points: points,

isBad: isBad,

caught: false

});


// Remove object after animation

setTimeout(() => {

if (object.parentNode) {

this.removeObject(object, false);

}

}, fallSpeed * 1000);

}


removeObject(objectElement, wasCaught) {

const objectIndex = this.fallingObjects.findIndex(obj => obj.element === objectElement);

if (objectIndex !== -1) {

const object = this.fallingObjects[objectIndex];


if (wasCaught) {

if (object.isBad) {

// Bad object caught - deduct points and life

this.score = Math.max(0, this.score - 20); // Deduct 20 points for catching bad object

this.lives--;

// Play bad catch sound
this.playBadCatchSound();

this.updateDisplay();

if (this.lives <= 0) {

this.gameOver();

}

} else {

// Good object caught - add points

this.score += object.points;

// Play sound based on object type
if (object.points === 50) {
// Bonus object
this.playBonusSound();
} else {
// Regular good object
this.playCatchSound();
}

this.updateDisplay();


// Check for level up

if (this.score > 0 && this.score % 100 === 0) {

this.levelUp();

}

}

} else if (object.isBad) {

// Bad object missed - no penalty

} else {

// Good object missed - lose life

this.lives--;

// Play miss sound
this.playMissSound();

this.updateDisplay();


if (this.lives <= 0) {

this.gameOver();

}

}


this.fallingObjects.splice(objectIndex, 1);

}


if (objectElement.parentNode) {

objectElement.remove();

}

}


levelUp() {

this.level++;

this.gameSpeed = Math.max(500, this.gameSpeed - 200); // Faster drops


// Clear current interval and set new one

clearInterval(this.dropInterval);

this.dropInterval = setInterval(() => {

this.createFallingObject();

}, this.gameSpeed);


this.updateDisplay();


// Visual feedback for level up

this.showLevelUpEffect();

}


showLevelUpEffect() {

const effect = document.createElement('div');

effect.style.position = 'absolute';

effect.style.top = '50%';

effect.style.left = '50%';

effect.style.transform = 'translate(-50%, -50%)';

effect.style.color = '#FFD700';

effect.style.fontSize = '24px';

effect.style.fontWeight = 'bold';

effect.style.pointerEvents = 'none';

effect.style.zIndex = '1000';

effect.textContent = `Level ${this.level}!`;


this.gameArea.appendChild(effect);


setTimeout(() => {

effect.remove();

}, 2000);

}


gameOver() {

this.gameRunning = false;

clearInterval(this.dropInterval);


// Stop background music
if (this.backgroundMusicSource) {
try {
if (this.backgroundMusicSource.osc1) this.backgroundMusicSource.osc1.stop();
if (this.backgroundMusicSource.osc2) this.backgroundMusicSource.osc2.stop();
if (this.backgroundMusicSource.osc3) this.backgroundMusicSource.osc3.stop();
if (this.backgroundMusicSource.musicTimeout) {
clearTimeout(this.backgroundMusicSource.musicTimeout);
}
} catch (e) {
// Oscillators may already be stopped
}
this.backgroundMusicSource = null;
}

// Play game over sound
this.playGameOverSound();


// Clear all falling objects

this.fallingObjects.forEach(obj => {

if (obj.element.parentNode) {

obj.element.remove();

}

});

this.fallingObjects = [];


this.finalScoreElement.textContent = this.score;

this.finalLevelElement.textContent = this.level;

this.gameOverElement.style.display = 'block';

}


updateDisplay() {

this.scoreElement.textContent = this.score;

this.livesElement.textContent = this.lives;

this.levelElement.textContent = this.level;

}

// Generate and play elevator-style background music
playElevatorMusic() {

if (!this.audioContext || this.backgroundMusicSource) return;

try {

const ctx = this.audioContext;

// Create a simple elevator music pattern using multiple oscillators
const osc1 = ctx.createOscillator();
const osc2 = ctx.createOscillator();
const osc3 = ctx.createOscillator();

const gain1 = ctx.createGain();
const gain2 = ctx.createGain();
const gain3 = ctx.createGain();

// Main melody - soft triangle wave
osc1.type = 'triangle';
osc1.frequency.value = 261.63; // C4

// Harmony - soft triangle wave
osc2.type = 'triangle';
osc2.frequency.value = 329.63; // E4

// Bass - very soft sine wave
osc3.type = 'sine';
osc3.frequency.value = 196.00; // G3

// Set volumes (low for elevator music feel)
gain1.gain.value = 0.15;
gain2.gain.value = 0.12;
gain3.gain.value = 0.10;

// Connect to gain node and then to destination
osc1.connect(gain1);
osc2.connect(gain2);
osc3.connect(gain3);

gain1.connect(this.musicGainNode);
gain2.connect(this.musicGainNode);
gain3.connect(this.musicGainNode);

// Create a sequence for elevator music pattern
let musicTimeout = null;

const scheduleNotes = () => {

if (!this.gameRunning || !this.musicEnabled) {
if (musicTimeout) clearTimeout(musicTimeout);
return;
}

const now = ctx.currentTime;
const notes = [261.63, 293.66, 329.63, 349.23, 392.00, 329.63, 293.66, 261.63];
const durations = [0.4, 0.4, 0.4, 0.4, 0.6, 0.4, 0.4, 0.4];

let timeOffset = 0;

notes.forEach((freq, i) => {

const osc = ctx.createOscillator();
const gain = ctx.createGain();

osc.type = 'triangle';
osc.frequency.value = freq;

gain.gain.setValueAtTime(0, now + timeOffset);
gain.gain.linearRampToValueAtTime(0.12, now + timeOffset + 0.01);
gain.gain.linearRampToValueAtTime(0, now + timeOffset + durations[i]);

osc.connect(gain);
gain.connect(this.musicGainNode);

osc.start(now + timeOffset);
osc.stop(now + timeOffset + durations[i]);

timeOffset += durations[i];

});

// Schedule next sequence
musicTimeout = setTimeout(() => scheduleNotes(), timeOffset * 1000);

};

// Start playing
scheduleNotes();

// Also play continuous soft background tones
osc1.start();
osc2.start();
osc3.start();

this.backgroundMusicSource = { osc1, osc2, osc3, musicTimeout };

} catch (e) {

console.log('Error playing elevator music:', e);

}

}

// Play catch sound effect
playCatchSound() {

if (!this.musicEnabled || !this.audioContext) return;

try {

const ctx = this.audioContext;
const osc = ctx.createOscillator();
const gain = ctx.createGain();

osc.type = 'sine';
osc.frequency.setValueAtTime(600, ctx.currentTime);
osc.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.1);

gain.gain.setValueAtTime(0.3, ctx.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);

osc.connect(gain);
gain.connect(ctx.destination);

osc.start();
osc.stop(ctx.currentTime + 0.2);

} catch (e) {

console.log('Error playing catch sound:', e);

}

}

// Play bonus sound effect
playBonusSound() {

if (!this.musicEnabled || !this.audioContext) return;

try {

const ctx = this.audioContext;

// Play a pleasant chime
[523.25, 659.25, 783.99].forEach((freq, i) => {

const osc = ctx.createOscillator();
const gain = ctx.createGain();

osc.type = 'sine';
osc.frequency.value = freq;

gain.gain.setValueAtTime(0.2, ctx.currentTime + i * 0.1);
gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.1 + 0.3);

osc.connect(gain);
gain.connect(ctx.destination);

osc.start(ctx.currentTime + i * 0.1);
osc.stop(ctx.currentTime + i * 0.1 + 0.3);

});

} catch (e) {

console.log('Error playing bonus sound:', e);

}

}

// Play miss sound effect
playMissSound() {

if (!this.musicEnabled || !this.audioContext) return;

try {

const ctx = this.audioContext;
const osc = ctx.createOscillator();
const gain = ctx.createGain();

osc.type = 'sawtooth';
osc.frequency.setValueAtTime(300, ctx.currentTime);
osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.15);

gain.gain.setValueAtTime(0.2, ctx.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);

osc.connect(gain);
gain.connect(ctx.destination);

osc.start();
osc.stop(ctx.currentTime + 0.2);

} catch (e) {

console.log('Error playing miss sound:', e);

}

}

// Play bad catch sound effect
playBadCatchSound() {

if (!this.musicEnabled || !this.audioContext) return;

try {

const ctx = this.audioContext;
const osc = ctx.createOscillator();
const gain = ctx.createGain();

osc.type = 'square';
osc.frequency.setValueAtTime(200, ctx.currentTime);
osc.frequency.exponentialRampToValueAtTime(150, ctx.currentTime + 0.2);

gain.gain.setValueAtTime(0.25, ctx.currentTime);
gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);

osc.connect(gain);
gain.connect(ctx.destination);

osc.start();
osc.stop(ctx.currentTime + 0.3);

} catch (e) {

console.log('Error playing bad catch sound:', e);

}

}

// Play game over sound effect
playGameOverSound() {

if (!this.musicEnabled || !this.audioContext) return;

try {

const ctx = this.audioContext;

// Descending tone sequence
[440, 392, 349, 293, 261].forEach((freq, i) => {

const osc = ctx.createOscillator();
const gain = ctx.createGain();

osc.type = 'sine';
osc.frequency.value = freq;

gain.gain.setValueAtTime(0.3, ctx.currentTime + i * 0.15);
gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.2);

osc.connect(gain);
gain.connect(ctx.destination);

osc.start(ctx.currentTime + i * 0.15);
osc.stop(ctx.currentTime + i * 0.15 + 0.2);

});

} catch (e) {

console.log('Error playing game over sound:', e);

}

}


gameLoop() {

if (!this.gameRunning) return;


// Check collisions

this.fallingObjects.forEach(obj => {

if (obj.caught) return;


const objectRect = obj.element.getBoundingClientRect();

const catcherRect = this.catcher.getBoundingClientRect();


// Check if object is near the catcher

if (objectRect.bottom >= catcherRect.top && 

objectRect.top <= catcherRect.bottom &&

objectRect.left < catcherRect.right && 

objectRect.right > catcherRect.left) {


obj.caught = true;

this.removeObject(obj.element, true);

}

});


requestAnimationFrame(() => this.gameLoop());

}

}


// Global functions

function restartGame() {

game.startGame();

}


// Music toggle function

function toggleMusic() {

const game = window.game;

if (!game) return;

game.musicEnabled = !game.musicEnabled;

const musicToggle = document.getElementById('musicToggle');
const musicIcon = musicToggle.querySelector('i');

if (game.musicEnabled) {

musicToggle.innerHTML = '<i class="fas fa-music"></i> Music: ON';

musicToggle.classList.remove('muted');

if (game.gameRunning && game.audioContext && !game.backgroundMusicSource) {

game.playElevatorMusic();

} else if (game.musicGainNode) {

game.musicGainNode.gain.value = 0.8;

}

} else {

musicToggle.innerHTML = '<i class="fas fa-volume-mute"></i> Music: OFF';

musicToggle.classList.add('muted');

if (game.musicGainNode) {

game.musicGainNode.gain.value = 0;

}

}

}


// Initialize game when page loads

let game;

window.addEventListener('load', () => {

game = new DropCatchGame();

window.game = game; // Make game accessible globally for toggleMusic function

});

</script>

</body>

</html>
